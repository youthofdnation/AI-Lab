<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì‹¤ì‹œê°„ ìŒì„± ì¸ì‹</title>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; padding: 20px; }
        button, select { padding: 10px 20px; margin: 10px; font-size: 16px; }
        #recognizedText { margin-top: 20px; font-size: 18px; font-weight: bold; }
        canvas { display: block; margin: 20px auto; background: #f0f0f0; }
        #timer { font-size: 16px; margin-top: 10px; color: #666; }
    </style>
</head>
<body>
    <h1>ì‹¤ì‹œê°„ ìŒì„± ì¸ì‹</h1>
    
    <label for="audioSource">ğŸ™ï¸ ì˜¤ë””ì˜¤ ì…ë ¥ ì¥ì¹˜ ì„ íƒ:</label>
    <select id="audioSource"></select>

    <button id="startRecording">ğŸ¤ ë…¹ìŒ ì‹œì‘</button>
    <button id="stopRecording" style="display: none;">â¹ï¸ ë…¹ìŒ ì¤‘ì§€</button>

    <p id="status">ë²„íŠ¼ì„ ëˆŒëŸ¬ ë…¹ìŒì„ ì‹œì‘í•˜ì„¸ìš”.</p>
    <div id="timer">ë…¹ìŒ ì‹œê°„: 0ì´ˆ</div>
    <div id="recognizedText">ì¸ì‹ëœ í…ìŠ¤íŠ¸: </div>

    <canvas id="waveform" width="600" height="150"></canvas>

    <script>
        let mediaRecorder;
        let audioChunks = [];
        let ws;
        let isRecording = false;
        let audioContext, analyser, dataArray, source;
        let canvas, canvasCtx;
        let recordingInterval;
        let timerInterval;
        let timeElapsed = 0;
        
        // ë…¹ìŒ ì‹œê°„ ì„¤ì • (ë°€ë¦¬ì´ˆ)
        const recordingDuration = 3000; // 3ì´ˆ

        async function getAudioDevices() {
            const devices = await navigator.mediaDevices.enumerateDevices();
            const audioSelect = document.getElementById("audioSource");
            audioSelect.innerHTML = ""; 

            const audioDevices = devices.filter(device => device.kind === "audioinput");
            audioDevices.forEach((device, index) => {
                let option = document.createElement("option");
                option.value = device.deviceId;
                option.text = device.label || `Microphone ${index + 1}`;
                audioSelect.appendChild(option);
            });
        }

        async function startRecording() {
            try {
                const audioSelect = document.getElementById("audioSource");
                const deviceId = audioSelect.value;
                const constraints = { audio: { deviceId: deviceId ? { exact: deviceId } : undefined } };
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                
                // WebSocket ì—°ê²°
                ws = new WebSocket("ws://localhost:8000/ws");
                
                ws.onopen = () => {
                    console.log("WebSocket ì—°ê²°ë¨");
                    startRecordingCycle(stream);
                };

                ws.onmessage = (event) => {
                    document.getElementById("recognizedText").textContent = "ì¸ì‹ëœ í…ìŠ¤íŠ¸: " + event.data;
                };

                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 1024;
                dataArray = new Uint8Array(analyser.frequencyBinCount);
                
                source = audioContext.createMediaStreamSource(stream);
                source.connect(analyser);
                
                canvas = document.getElementById("waveform");
                canvasCtx = canvas.getContext("2d");
                
                document.getElementById("startRecording").style.display = "none";
                document.getElementById("stopRecording").style.display = "inline-block";
                document.getElementById("status").textContent = "ë…¹ìŒ ì¤‘...";
                
                // íƒ€ì´ë¨¸ ì‹œì‘
                timeElapsed = 0;
                updateTimer();
                timerInterval = setInterval(updateTimer, 1000);
                
                // íŒŒí˜• ê·¸ë¦¬ê¸° ì‹œì‘
                isRecording = true;
                drawWaveform();
            } catch (error) {
                console.error("ë…¹ìŒ ì˜¤ë¥˜:", error);
            }
        }
        
        function startRecordingCycle(stream) {
            if (!isRecording) return;
            
            // ì´ì „ ì²­í¬ ì´ˆê¸°í™”
            audioChunks = [];
            
            // ìƒˆ ë¯¸ë””ì–´ ë ˆì½”ë” ìƒì„±
            mediaRecorder = new MediaRecorder(stream);
            
            mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    audioChunks.push(event.data);
                }
            };
            
            mediaRecorder.onstop = () => {
                if (ws.readyState === WebSocket.OPEN && audioChunks.length > 0) {
                    // ë…¹ìŒëœ ë°ì´í„°ë¥¼ ì„œë²„ë¡œ ì „ì†¡
                    const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                    ws.send(audioBlob);
                    console.log("3ì´ˆ ë…¹ìŒ ë°ì´í„° ì „ì†¡ ì™„ë£Œ");
                    
                    // ë…¹ìŒ ê³„ì†í•˜ê¸°
                    if (isRecording) {
                        startRecordingCycle(stream);
                    }
                }
            };
            
            // ë…¹ìŒ ì‹œì‘
            mediaRecorder.start();
            console.log("ìƒˆ ë…¹ìŒ ì„¸ì…˜ ì‹œì‘");
            
            // ì§€ì •ëœ ì‹œê°„ í›„ì— ë…¹ìŒ ì¤‘ì§€
            setTimeout(() => {
                if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                    mediaRecorder.stop();
                }
            }, recordingDuration);
        }

        function stopRecording() {
            isRecording = false;
            
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
            }
            
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.close();
            }
            
            if (audioContext) {
                audioContext.close();
            }
            
            // íƒ€ì´ë¨¸ ì¤‘ì§€
            clearInterval(timerInterval);

            document.getElementById("startRecording").style.display = "inline-block";
            document.getElementById("stopRecording").style.display = "none";
            document.getElementById("status").textContent = "ë…¹ìŒì´ ì¤‘ì§€ë˜ì—ˆìŠµë‹ˆë‹¤.";
        }
        
        function updateTimer() {
            if (isRecording) {
                document.getElementById("timer").textContent = `ë…¹ìŒ ì‹œê°„: ${timeElapsed}ì´ˆ`;
                timeElapsed++;
            }
        }

        function drawWaveform() {
            if (!isRecording) return;
            requestAnimationFrame(drawWaveform);
            
            analyser.getByteTimeDomainData(dataArray);
            canvasCtx.fillStyle = "white";
            canvasCtx.fillRect(0, 0, canvas.width, canvas.height);

            canvasCtx.lineWidth = 2;
            canvasCtx.strokeStyle = "blue";
            canvasCtx.beginPath();

            const sliceWidth = canvas.width / dataArray.length;
            let x = 0;
            for (let i = 0; i < dataArray.length; i++) {
                const y = (dataArray[i] / 255.0) * canvas.height;
                i === 0 ? canvasCtx.moveTo(x, y) : canvasCtx.lineTo(x, y);
                x += sliceWidth;
            }

            canvasCtx.stroke();
        }

        document.getElementById("startRecording").addEventListener("click", startRecording);
        document.getElementById("stopRecording").addEventListener("click", stopRecording);

        navigator.mediaDevices.getUserMedia({ audio: true }).then(getAudioDevices).catch(err => console.error("ì˜¤ë””ì˜¤ ì¥ì¹˜ ì ‘ê·¼ ì˜¤ë¥˜:", err));
    </script>
</body>
</html>